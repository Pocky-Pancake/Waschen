import nextcord, os, re, sqlite3, time
from utils import *
from nextcord import Interaction
from nextcord.ext import commands, application_checks
from dotenv import load_dotenv

load_dotenv()

activity = nextcord.Activity(type=nextcord.ActivityType.watching, name="#bookworm-memes")
intents = nextcord.Intents.all()
client = nextcord.Client(intents=intents, activity=activity)

conn = sqlite3.connect("bot.sqlite3")
c = conn.cursor()

c.execute("""CREATE TABLE IF NOT EXISTS threads (
    user_id integer,
    thread_id integer,
    guild_id integer,
    embedmsg_id integer
)""")

c.execute("""CREATE TABLE IF NOT EXISTS targets (
    channel_id integer,
    guild_id integer,
    type integer,
    warn_msg text,
    default_thread_name text
)""")

# TYPE:
# 0 = filter
# 2 = logs

@client.event
async def on_ready():
    print(f"{client.user.name} is ready")

@client.event
async def on_application_command_error(interaction:Interaction, error):
    error = getattr(error, "original", error)
    if isinstance(error, application_checks.ApplicationMissingPermissions):
        await interaction.response.send_message(f"{error}", ephemeral=True)
        await doLog(f"{error}", client, c, interaction.guild)
    else:
        await doLog(f"{error}", client, c, interaction.guild)
        raise error

urlRegex = r"https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)"

@client.event
async def on_message(message):
    filters = c.execute("SELECT channel_id FROM targets WHERE type = 0").fetchall()
    for x in filters:
        if message.channel.id == x[0]:
            if message.attachments or re.search(urlRegex, message.content):
                for y in client.get_all_application_commands():
                    if y.qualified_name == "rename":
                        rename_slash = y
                thread = await message.create_thread(name=f"{message.author.name}'s meme discussion")
                embed = nextcord.Embed(title="New Meme Discussion Thread", description=f"Use üìù button to rename it.\n\nThis will only be valid for the first 10 minutes. To rename the thread afterwards use {rename_slash.get_mention(guild=None)} instead.", color=0x3366cc)
                embed.set_footer(icon_url=message.author.avatar ,text=f"This thread has been initialized by {message.author.name}")
                embedmsg = await thread.send(embed=embed, view=threadView(thread, message.author.id, client, False))
                await thread.leave()
                sql = "INSERT INTO threads (user_id, thread_id, guild_id, embedmsg_id) VALUES (?, ?, ?)"
                val = (message.author.id, thread.id, message.guild.id, embedmsg.id)
                c.execute(sql,val)
                conn.commit()
                await doLog(f"Thread auto-generated by {message.author.name}", client, c, message.guild)
                time.sleep(600)
                await embedmsg.edit(embed=embed, view=threadView(thread, message.author.id, True))
            elif message.type.pins_add:
                pass
            elif message.author.guild_permissions.manage_channels:
                await doLog(f"Message passed ({message.author.name})", client, c, message.guild)
            else:
                try:
                    await message.author.send(f"In order to keep {message.channel.mention} as organized as possible, it is only possible to discuss memes via threads.")
                except:
                    await message.channel.send(f"{message.author.mention}\nIn order to keep {message.channel.mention} as organized as possible, it is only possible to discuss memes via threads.", delete_after=30)
                await doLog(f"Deleted message from {message.author.name}", client, c, message.guild)
                await message.delete()

@client.slash_command(description="Renames a registered meme discussion thread you started.")
async def rename(interaction:Interaction):
    try:
        thread_id = c.execute(f"SELECT thread_id FROM threads WHERE thread_id = {interaction.channel.id}").fetchone()[0]
        user_id = c.execute(f"SELECT user_id FROM threads WHERE thread_id = {thread_id}").fetchone()[0]
    except:
        thread_id = None
        user_id = None
    if interaction.channel.id == thread_id and interaction.user.id == user_id:
        thread = await client.fetch_channel(thread_id)
        await interaction.response.send_modal(renameModal(thread))
    else:
        await interaction.response.send_message("This channel is either not a thread, not a registered thread or you don't own this thread.", ephemeral=True)

@client.slash_command(description="Check bot status and latency.")
async def stats(interaction:Interaction):
    permit = True
    # for x in c.execute("SELECT channel_id FROM targets WHERE type = 1").fetchall():
    #    if interaction.channel.id == int(x[0]):
    #        permit = True
    if permit:
        await getPage(interaction, client, c, 1, 3)
    else:
        await interaction.response.send_message("This command is only possible in the valid bots channels.", ephemeral=True)

@client.slash_command(description="Add functionning channels.")
@application_checks.has_permissions(manage_channels=True)
async def add_channel(interaction:Interaction, channel:nextcord.TextChannel = nextcord.SlashOption(description="Target channel (Text channel only)."), setType:int = nextcord.SlashOption(description="Choose which functionning type.", choices={"As filter channel":0, "As logging channel":2}, name="as")):
    check = c.execute(f"SELECT channel_id FROM targets WHERE type = {setType} AND channel_id = {channel.id}").fetchone()
    typeName = {0:"filter channel.", 1:"bots channel", 2:"logs channel"}
    if not check:
        if setType == 0:
            await filterModal(channel, c, conn, False)
        else:
            sql = "INSERT INTO targets (channel_id, guild_id, type, warn_msg default_thread_name) VALUES (?, ?, ?)"
            val = (channel.id, interaction.guild.id, setType, None, None, None)
            c.execute(sql,val)
            conn.commit()
            await interaction.response.send_message(f"{channel.mention} has been added as {typeName[setType]}.", ephemeral=True)
    else:
        await interaction.response.send_message(f"{channel.mention} is already added as {typeName[setType]}.", ephemeral=True)

@client.slash_command(description="Remove functionning channels.")
@application_checks.has_permissions(manage_channels=True)
async def rm_channel(interaction:Interaction, channel:nextcord.TextChannel = nextcord.SlashOption(description="Target channel (Text channel only)."), setType:int = nextcord.SlashOption(description="Choose which functionning type.", choices={"As filter channel":0, "As logging channel":2}, name="from")):
    check = c.execute(f"SELECT channel_id FROM targets WHERE type = {setType} AND channel_id = {channel.id}").fetchone()
    if check:
        pass
    else:
        pass

# @client.slash_command(description="Configurate filter channel.")
# @application_checks.has_permissions(manage_channels=True)
# async def conf_filter(interaction:Interaction, channel:nextcord.TextChannel = nextcord.SlashOption(description="Target channel (Text channel only).", name="Channel")):
#     pass

try:
    client.run(os.getenv('TOKEN'))
except:
    print("Failed to connect.")
